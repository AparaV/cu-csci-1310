'''
Image manipulation, slices, color 

sudo apt-get install python-matplotlib
sudo apt-get install python-tk
'''
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

'''
We see 2d arrays when we look at image data, and this is also an interesting
way to examine what happens when we examine individual elements of an
image. There is a file on Moodle called dolphin_swimming.jpg. You can 
open it here using matplotlib command imread. 
'''
imgDolphin=mpimg.imread('dolphin_swimming.jpg')
'''
Lets display it and then look at the data in imgDolphin.
'''

imgPlotDolphin = plt.imshow(imgDolphin)
plt.show()

'''
Let's look at imgDolphin
What shape is it, an what type is it?
'''
print imgDolphin.shape
print type(imgDolphin)
'''
Notice that the shape has a rows, columns, and then a third number.
That is the r,g,b values for the pixel at the row and column. The 
smallest unit of display on a computer screen is called a pixel, and 
the color that you see for a pixel is built from how much red, how much
green, and how much blue is in that pixel. The value for each of the
weights here is between 0-255.

There are a finite number of combinations of r,g,b weights. If each 
weight is 0-255, then there are 256^3 possible colors that can be 
generated by different weights on r,g,b.

Look at a blue region of the dolphin image and we should see that the 
blue weights are higher than the others.
'''
imgBlue = imgDolphin[400:610,800:1200]
print imgBlue
imgPlotDolphin = plt.imshow(imgBlue)
plt.show()
 
'''
If the weights are just numbers, then what happens if we add another
number to them. It changed the weights for r,g,b.
'''
imgDolphinNew = imgDolphin + 50
print imgDolphin[1:2,1:2]
print imgDolphinNew[1:2,1:2]
imgPlotDolphin = plt.imshow(imgDolphinNew)
plt.show()

'''
Lets add 150 to each one. Here, we see the limitations of 8-bit values,
and a difference between Matlab and matplotlib. The max value is 255, 
and adding 150 to everything causes some of the numbers to go over 255.
The values wrap around, startng back at 0.
'''

imgDolphinNew = imgDolphin + 150
print imgDolphin[1:2,1:2]
print imgDolphinNew[1:2,1:2]
imgPlotDolphin = plt.imshow(imgDolphinNew)
plt.show()

'''
img = img / 255.
#imgplot = plt.imshow(img)
#plt.show()
dolphinShape = img.shape
#print dolphinShape
'''

imgStarWars=mpimg.imread('starWars.jpg')
imgPlotStarWars = plt.imshow(imgStarWars)
plt.show()
starShape = imgStarWars.shape

print starShape

'''
Create a new image that is the overlap of these two. Here we put the
star wars image in the upper left corner. We could put it anywhere by
changing the indices that we're summing.
'''

imgDolphin[0:starShape[0],0:starShape[1]] = imgDolphin[0:starShape[0],0:starShape[1]] + imgStarWars
imgPlotDolphin = plt.imshow(imgDolphin)
plt.show()

#exercise: put the star wars image in the middle of the dolphin image
dolphinShape = imgDolphin.shape
#x = int(dolphinShape) / 2
#y = int(dolphinShape) / 2
imgDolphin[dolphinShape[0]/2:dolphinShape[0]/2+starShape[0], dolphinShape[1]/2:dolphinShape[1]/2+starShape[1]] += imgStarWars
imgPlotDolphin = plt.imshow(imgDolphin)
plt.show()

'''
Remove a color by setting its weight to zero for the entire image
'''
#print imgDolphinNoBlue
#how big is the dolphin image
'''
When we use the [start:end] notation, we are effectively looping through
the image between start and end and making the change at that location.
The size of an image is stored in the shape property.

'''
dolphinShape = imgDolphin.shape
for x in range(dolphinShape[0]):
	for y in range(dolphinShape[1]):
		imgDolphin[x,y,2] = 0
imgDolphinPlot = plt.imshow(imgDolphin)
plt.show()

